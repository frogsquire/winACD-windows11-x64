/* Copyright (C) 2005 Laurent Morichetti
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

#define _ACD_FILTER_C 1

/**
 * acdfilter.c: Apple HID Monitor Controls WDM filter driver.
 */

#include <wdm.h>
#include <usb.h>
#include <usbioctl.h>
#include <usbdlib.h>
#include <hidport.h>

#include "acdfilter.h"

/** Include the descriptors */
#include "acddescriptors.c"

/**
 * DriverEntry: Driver initialization entry point.
 */
NTSTATUS
DriverEntry (IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    ULONG i;

    PAGED_CODE ();
    UNREFERENCED_PARAMETER (RegistryPath);

    ACD_dbgPrint (("DriverEntry"));

    /* initialize our function pointers. */
    DriverObject->DriverExtension->AddDevice = ACD_AddDevice;
    DriverObject->DriverUnload = ACD_DriverUnload;

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
	DriverObject->MajorFunction [i] = ACD_DispatchAny;
    }
    /* the WDM requires us to have specific PnP & Power dispatch routines */
    DriverObject->MajorFunction [IRP_MJ_POWER] = ACD_DispatchPower;
    DriverObject->MajorFunction [IRP_MJ_PNP] = ACD_DispatchPnP;

    /* we need to filter the hid report descriptor */
    DriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] =
	ACD_DispatchIoctl;

    /* that's it! */
    return STATUS_SUCCESS;
}

/**
 * ACD_AddDevice: Create, initialize and attach a new filter device object.
 */
NTSTATUS
ACD_AddDevice (IN PDRIVER_OBJECT DriverObject,
	       IN PDEVICE_OBJECT PhysicalDeviceObject)
{
    PDEVICE_OBJECT filterDeviceObject = NULL;
    PDEVICE_OBJECT lowerDeviceObject;
    PDEVICE_EXTENSION deviceExt;
    NTSTATUS status;

    ACD_dbgPrint (("AddDevice"));

    /* create the filter device object to attach to the stack */
    status = IoCreateDevice (
	DriverObject,
	sizeof (DEVICE_EXTENSION),
	NULL,
	FILE_DEVICE_UNKNOWN,
	FILE_AUTOGENERATED_DEVICE_NAME,
	FALSE,
	&filterDeviceObject
	);

    if (!NT_SUCCESS (status))
	return status;

    /* initialize the filter device extension */
    deviceExt = (PDEVICE_EXTENSION) filterDeviceObject->DeviceExtension;
    RtlZeroMemory (deviceExt, sizeof (DEVICE_EXTENSION));
    deviceExt->physicalDeviceObject = PhysicalDeviceObject;

    /* attach our new filter device to the device stack */
    IoInitializeRemoveLock (&deviceExt->removeLock, 0, 0, 255);
    lowerDeviceObject = IoAttachDeviceToDeviceStack (
	filterDeviceObject, PhysicalDeviceObject
	);
    ASSERT (lowerDeviceObject != NULL);
    deviceExt->lowerDeviceObject = lowerDeviceObject;

    /* maintain IO/POWER related flags */
    filterDeviceObject->Flags |= lowerDeviceObject->Flags
	& (DO_DIRECT_IO | DO_BUFFERED_IO | DO_POWER_PAGABLE | DO_POWER_INRUSH);

    /* maintain the lower device's characteristics */
    filterDeviceObject->DeviceType = lowerDeviceObject->DeviceType;
    filterDeviceObject->Characteristics = lowerDeviceObject->Characteristics;
    filterDeviceObject->AlignmentRequirement =
	lowerDeviceObject->AlignmentRequirement;

    /* we can now receive IRPs */
    filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

/**
 * ACD_DriverUnload: Cleanup whatever DriverEntry might have created.
 */
VOID
ACD_DriverUnload (IN PDRIVER_OBJECT DriverObject)
{
    ACD_dbgPrint (("DriverUnload"));
    /* Nothing to do */
}

NTSTATUS
ACD_CompleteRequest (IN PIRP Irp, IN NTSTATUS Status, IN ULONG Info)
{
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = Info;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Status;
}

/**
 * ACD_DispatchAny: Our generic dispatch routine (call the lower driver).
 */
NTSTATUS
ACD_DispatchAny (IN PDEVICE_OBJECT FilterDeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION deviceExt;
    NTSTATUS status;

    deviceExt = (PDEVICE_EXTENSION) FilterDeviceObject->DeviceExtension;
    status = IoAcquireRemoveLock (&deviceExt->removeLock, Irp);
    if (!NT_SUCCESS (status))
	return ACD_CompleteRequest (Irp, status, 0);

    IoSkipCurrentIrpStackLocation (Irp);
    status = IoCallDriver (deviceExt->lowerDeviceObject, Irp);
    IoReleaseRemoveLock (&deviceExt->removeLock, Irp);

    return status;
}

/**
 * ACD_DispatchIoctl: Our own IRP_MJ_INTERNAL_DEVICE_CONTROL dispatch routine.
 */
NTSTATUS
ACD_DispatchIoctl (IN PDEVICE_OBJECT FilterDeviceObject, IN PIRP Irp)
{
    BOOLEAN completeRequestHere = FALSE;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExt;
    ULONG cCode;
    NTSTATUS status;

    deviceExt = (PDEVICE_EXTENSION) FilterDeviceObject->DeviceExtension;
    status = IoAcquireRemoveLock (&deviceExt->removeLock, Irp);
    if (!NT_SUCCESS (status))
	return ACD_CompleteRequest (Irp, status, 0);

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    cCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    if (cCode == IOCTL_INTERNAL_USB_SUBMIT_URB) {
	PURB urb = (PURB) irpStack->Parameters.Others.Argument1;
	struct _URB_CONTROL_DESCRIPTOR_REQUEST* desc =
	    (struct _URB_CONTROL_DESCRIPTOR_REQUEST *) urb;
	USHORT function = urb->UrbHeader.Function;

	if (function == URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
	    && desc->DescriptorType == USB_STRING_DESCRIPTOR_TYPE) {
	    if (desc->Index <= ACD_LAST_DRIVER_STRING_DESCRIPTOR) {
		status = ACD_FillControlDescriptorRequest (urb,
		    (PUCHAR) deviceExt->stringDescriptor [desc->Index],
		    deviceExt->stringDescriptor [desc->Index]->bLength
		    );
	    }
	    else {
		desc->TransferBufferLength = 0;
		urb->UrbHeader.Status = USBD_STATUS_STALL_PID;
		status = STATUS_UNSUCCESSFUL;
	    }
	    completeRequestHere = TRUE;
	}
	else if (function == URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
	    && desc->DescriptorType == USB_CONFIGURATION_DESCRIPTOR_TYPE) {
	    /* return our own device configuration descriptor */
	    switch (deviceExt->idProduct) {
	    case 0x9217: case 0x9218: case 0x9219:
		status = ACD_FillControlDescriptorRequest (
		    urb, (PUCHAR) &ACD_Clear_ConfigurationDescriptor,
		    sizeof (ACD_CONFIGURATION_DESCRIPTOR)
		    );
		break;
	    default:
		status = ACD_FillControlDescriptorRequest (
		    urb, (PUCHAR) &ACD_Aluminum_ConfigurationDescriptor,
		    sizeof (ACD_CONFIGURATION_DESCRIPTOR)
		    );
		break;
	    }
	    completeRequestHere = TRUE;
	}
	else if (function == URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE
		 && desc->DescriptorType == HID_REPORT_DESCRIPTOR_TYPE) {
	    /* return our own interface report descriptor */
	    switch (deviceExt->idProduct) {
	    case 0x9217: case 0x9218: case 0x9219:
		status = ACD_FillControlDescriptorRequest (
		    urb, (PUCHAR) ACD_Clear_HidReportDescriptor,
		    sizeof (ACD_Clear_HidReportDescriptor)
		    );
		break;
	    default:
		status = ACD_FillControlDescriptorRequest (
		    urb, (PUCHAR) ACD_Aluminum_HidReportDescriptor,
		    sizeof (ACD_Aluminum_HidReportDescriptor)
		    );
		break;
	    }
	    completeRequestHere = TRUE;
	}
    }

    if (completeRequestHere) {
	Irp->IoStatus.Status = status;
	IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }
    else {
	IoSkipCurrentIrpStackLocation (Irp);
	status = IoCallDriver (deviceExt->lowerDeviceObject, Irp);
    }
    IoReleaseRemoveLock (&deviceExt->removeLock, Irp);
    return status;
}

/**
 * ACD_DispatchPower: Our own Power dispatch routine. Call the lower
 * driver with PoCallDriver instead of IoCallDriver.
 */
NTSTATUS
ACD_DispatchPower (IN PDEVICE_OBJECT FilterDeviceObject, IN PIRP Irp)
{
    PDEVICE_EXTENSION deviceExt;
    NTSTATUS status;

    PoStartNextPowerIrp (Irp);

    deviceExt = (PDEVICE_EXTENSION) FilterDeviceObject->DeviceExtension;
    status = IoAcquireRemoveLock (&deviceExt->removeLock, Irp);
    if (!NT_SUCCESS (status))
	return ACD_CompleteRequest (Irp, status, 0);

    IoSkipCurrentIrpStackLocation (Irp);
    status = PoCallDriver (deviceExt->lowerDeviceObject, Irp);
	
    IoReleaseRemoveLock (&deviceExt->removeLock, Irp);
    return status;
}

/**
 * ACD_DispatchPnP: Our own PnP dispatch routine. Allows us to catch
 * the IRP_MN_START_DEVICE and IRP_MN_REMOVE_DEVICE irps.
 */
NTSTATUS
ACD_DispatchPnP (IN PDEVICE_OBJECT FilterDeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExt;
    ULONG minor;
    NTSTATUS status;

    deviceExt = (PDEVICE_EXTENSION) FilterDeviceObject->DeviceExtension;
    status = IoAcquireRemoveLock (&deviceExt->removeLock, Irp);
    if (!NT_SUCCESS (status))
	return ACD_CompleteRequest (Irp, status, 0);

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    minor = irpStack->MinorFunction;

    /* handle START_DEVICE here since we want to emit a RESET after
     * completion of the lower stack.
     */
    if (minor == IRP_MN_START_DEVICE) {
	PUSB_DEVICE_DESCRIPTOR desc;
	KEVENT event;

	KeInitializeEvent (&event, NotificationEvent, FALSE);

	IoCopyCurrentIrpStackLocationToNext (Irp);
	IoSetCompletionRoutine (
	    Irp, ACD_IoCallDriverCompletion, &event, TRUE, TRUE, TRUE
	    );

	status = IoCallDriver (deviceExt->lowerDeviceObject, Irp);

	/* wait for the call to complete (we'll get notified by
	 * the completion routine.
	 */
	KeWaitForSingleObject (
	    &event, Executive, KernelMode, FALSE, NULL
	    );

	status = Irp->IoStatus.Status;

	/* for some reason the device is not functioning properly
	 * after START_DEVICE. Reseting the port seems to wake the
	 * HID monitor controls up.
	 */
	if (NT_SUCCESS (status)) {
	    status = ACD_ResetPort (deviceExt->lowerDeviceObject);
	    Irp->IoStatus.Status = status;
	}

	if (NT_SUCCESS (status))
	    status = ACD_CacheStringDescriptors (deviceExt);

	/* Get the ProductID out of the device descriptor */
	desc = ExAllocatePool (NonPagedPool, sizeof (USB_DEVICE_DESCRIPTOR));
	if (desc == NULL)
	    return STATUS_INSUFFICIENT_RESOURCES;

	if (NT_SUCCESS (status)) {
	    status = ACD_GetDeviceDescriptor (
		deviceExt->lowerDeviceObject, desc,
		sizeof (USB_DEVICE_DESCRIPTOR));

	    deviceExt->idProduct = desc->idProduct;
	}

	ExFreePool (desc);

	/* we're done with this IRP, we can complete it here */
	Irp->IoStatus.Status = status;
	IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }
    else {
	IoSkipCurrentIrpStackLocation (Irp);
	status = IoCallDriver (deviceExt->lowerDeviceObject, Irp);
    }

    if (minor == IRP_MN_REMOVE_DEVICE) {
	size_t i;
	for (i = 0; i <= ACD_LAST_DRIVER_STRING_DESCRIPTOR; ++i)
	    if (deviceExt->stringDescriptor [i] != NULL)
		ExFreePool (deviceExt->stringDescriptor [i]);

	IoReleaseRemoveLockAndWait (&deviceExt->removeLock, Irp);
	IoDetachDevice (deviceExt->lowerDeviceObject);
	IoDeleteDevice (FilterDeviceObject);
    }
    else {
        IoReleaseRemoveLock (&deviceExt->removeLock, Irp);
    }

    return status;
}

/**
 * ACD_IoCallDriverCompletion: Synchronized IoCallDriver completion routine.
 * It will notify the waiting thread that the call as completed.
 */
NTSTATUS
ACD_IoCallDriverCompletion (IN PDEVICE_OBJECT DeviceObject,
			    IN PIRP Irp, IN PVOID Context)
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    KeSetEvent((PKEVENT) Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

/**
 * ACD_CacheStringDescriptors: Cache the device string descriptors in memory.
 */
NTSTATUS
ACD_CacheStringDescriptors (IN OUT PDEVICE_EXTENSION DeviceExt)
{
    PUSB_STRING_DESCRIPTOR desc0;
    NTSTATUS status;
    UCHAR index;

    /* allocate desc0 */
    desc0 = ExAllocatePool (NonPagedPool, sizeof (USB_STRING_DESCRIPTOR));
    if (desc0 == NULL)
	return STATUS_INSUFFICIENT_RESOURCES;

    for (index = 1; index <= ACD_LAST_DEVICE_STRING_DESCRIPTOR; ++index) {
	PUSB_STRING_DESCRIPTOR desc;

	/* get StringDescN->bLenth */
	RtlZeroMemory (desc0, sizeof (USB_STRING_DESCRIPTOR));
	status = ACD_GetStringDescriptor (
	    DeviceExt->lowerDeviceObject, index,
	    desc0, sizeof (USB_STRING_DESCRIPTOR)
	    );
	if (!NT_SUCCESS (status)) {
	    ExFreePool (desc0);
	    return status;
	}

	/* get StringDescN */
	desc = ExAllocatePool (NonPagedPool, desc0->bLength);
	if (desc == NULL) {
	    ExFreePool (desc0);
	    return STATUS_INSUFFICIENT_RESOURCES;
	}

	RtlZeroMemory (desc, desc0->bLength);
	status = ACD_GetStringDescriptor (
	    DeviceExt->lowerDeviceObject, index, desc, desc0->bLength
	    );
	if (!NT_SUCCESS (status)) {
	    ExFreePool (desc0);
	    ExFreePool (desc);
	    return status;
	}
	DeviceExt->stringDescriptor [index] = desc;
    }

    /* get StringDesc0 */
    status = ACD_GetStringDescriptor (
	DeviceExt->lowerDeviceObject, 0, desc0, sizeof (USB_STRING_DESCRIPTOR)
	);
    if (!NT_SUCCESS (status)) {
	ExFreePool (desc0);
	return status;
    }

    DeviceExt->stringDescriptor [0] = desc0;
    return status;
}

/**
 * ACD_GetStringDescriptor: Extract a USB string descriptor.
 */
NTSTATUS
ACD_GetStringDescriptor (IN PDEVICE_OBJECT LowerDeviceObject,
			 IN UCHAR Index,
			 IN OUT PUSB_STRING_DESCRIPTOR pDescriptor,
			 IN ULONG Size)
{
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PURB urb = ExAllocatePool (NonPagedPool, 
	sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (!urb)
	return STATUS_INSUFFICIENT_RESOURCES;

    UsbBuildGetDescriptorRequest (
	urb, 
	(USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
	USB_STRING_DESCRIPTOR_TYPE, 
	Index,
	0x0409,
	pDescriptor, 
	NULL, 
	Size,
	NULL);

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
	IOCTL_INTERNAL_USB_SUBMIT_URB, LowerDeviceObject,
	NULL, 0, NULL, 0, TRUE, &event, &ioStatus
	);

    if (irp == NULL) {
	ExFreePool (urb);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation (irp);
    irpStack->Parameters.Others.Argument1 = urb;

    status = IoCallDriver (LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
	KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
	status = ioStatus.Status;
    }

    ExFreePool (urb);
    return status;
}

/**
 * ACD_GetDeviceDescriptor: Extract a USB device descriptor.
 */
NTSTATUS
ACD_GetDeviceDescriptor (IN PDEVICE_OBJECT LowerDeviceObject,
			 IN OUT PUSB_DEVICE_DESCRIPTOR pDescriptor,
			 IN ULONG Size)
{
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PURB urb = ExAllocatePool (NonPagedPool, 
	sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (!urb)
	return STATUS_INSUFFICIENT_RESOURCES;

    UsbBuildGetDescriptorRequest (
	urb, 
	(USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
	USB_DEVICE_DESCRIPTOR_TYPE, 
	0,
	0,
	pDescriptor, 
	NULL, 
	Size,
	NULL);

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
	IOCTL_INTERNAL_USB_SUBMIT_URB, LowerDeviceObject,
	NULL, 0, NULL, 0, TRUE, &event, &ioStatus
	);

    if (irp == NULL) {
	ExFreePool (urb);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation (irp);
    irpStack->Parameters.Others.Argument1 = urb;

    status = IoCallDriver (LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
	KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
	status = ioStatus.Status;
    }

    ExFreePool (urb);
    return status;
}

/**
 * ACD_FillControlDescriptorRequest: Fill an URB with the given control desc.
 */
NTSTATUS
ACD_FillControlDescriptorRequest (IN PURB Urb, IN PUCHAR Buffer,
				  IN ULONG BufferLength)
{
    struct _URB_CONTROL_DESCRIPTOR_REQUEST *desc =
	(struct _URB_CONTROL_DESCRIPTOR_REQUEST *) Urb;
    ULONG length = BufferLength < desc->TransferBufferLength
	? BufferLength : desc->TransferBufferLength;

    if (Buffer == NULL) {
	return STATUS_INVALID_PARAMETER;
    }

    RtlCopyMemory (desc->TransferBuffer, Buffer, length);
    desc->TransferBufferLength = length;

    Urb->UrbHeader.Status = USBD_STATUS_SUCCESS;
    return STATUS_SUCCESS;
}

/**
 * ACD_GetPortStatus: Get the device's port status.
 */
NTSTATUS
ACD_GetPortStatus (IN PDEVICE_OBJECT LowerDeviceObject, IN OUT PULONG Flags)
{
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    *Flags = 0;

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
	IOCTL_INTERNAL_USB_GET_PORT_STATUS, LowerDeviceObject,
	NULL, 0, NULL, 0, TRUE, &event, &ioStatus
	);

    if (irp == NULL)
	return STATUS_INSUFFICIENT_RESOURCES;

    irpStack = IoGetNextIrpStackLocation (irp);
    irpStack->Parameters.Others.Argument1 = Flags;

    status = IoCallDriver (LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
	KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
	return ioStatus.Status;
    }

    return status;
}

/**
 * ACD_ResetPort: Reset the device's port.
 */
NTSTATUS
ACD_ResetPort (IN PDEVICE_OBJECT LowerDeviceObject)
{
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    KeInitializeEvent (&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest (
	IOCTL_INTERNAL_USB_RESET_PORT, LowerDeviceObject,
	NULL, 0, NULL, 0, TRUE, &event, &ioStatus
	);

    if (irp == NULL)
	return STATUS_INSUFFICIENT_RESOURCES;

    ioStatus.Status = STATUS_NOT_SUPPORTED;
    status = IoCallDriver (LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
	KeWaitForSingleObject (&event, Executive, KernelMode, FALSE, NULL);
	return ioStatus.Status;
    }

    return status;
}